4.1
    105

4.2
    (a)*(vec.begin())
    (b)(*(vec.begin()) + 1

4.3
    可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。
    
4.4
    ((12/3)*4)+(5*15)+((24%4)/2)
    结果为91
    code

4.5
    (a)-86
    (b)-18
    (c)0
    (d)-2

4.6
    x & 1 == 0 ? 偶数 : 奇数

4.7
    溢出是数据超出了当前数据类型所能表达的最小或最大数字
    int a = INT_MAX + 1;
    int a = INT_MIN - 1;
    unsigned a = -1;

4.8
    逻辑与中先求解左侧运算对象，如果求解结果为true则求解右侧运算对象，如果求解结果为false，则不再求解右侧运算对象
    逻辑与中先求解左侧运算对象，如果求解结果为false则求解右侧运算对象，如果求解结果为true，则不再求解右侧运算对象
    相等性运算符中运算对象的求值顺序不确定

4.9
    先判断cp，由于cp不为NULL，接着判断*cp，由于*cp的值为'H'不为0，所以执行if中语句

4.10
    int a;
    while((cin >> a) && a != 42) ;

4.11
    if(a > b && b > c && c > d)

4.12
    这个表达式等价于i != (j < k)，首先得到 j < k 的结果为 true 或 false，转换为整数值是 1 和 0，然后判断 i 不等于 1 和 0 ，最终的结果为 bool 值。

4.13
    (a)i=3, d=3.0
    (b)d=3.5, i = 3

4.14
    第一个语句出错，赋值运算符左侧必须是一个可修改的左值，二字面值是右值
    第二个语句永远为true

4.15
    int *p = 0是合法的
    0可以赋值给任何对象，这里0隐式地转换为null_ptr，此题错在指针类型不能隐式地转换为int整形类型。
    可修改为dval = ival = *pi = 1;

4.16
    (a)因为=运算符的优先级低于!=运算符，应该改为if((p = getPtr()) != 0)
    (b)应该使用==运算符，而不应该是用=运算符

4.17
    前置递增运算符先将运算对象+1，然后以左值形式返回运算对象
    后置递增运算符以右值返回运算对象的副本，然后将运算对象+1

4.18
    将会跳过vector中的第一个元素，并且最后会对v.end()进行取值，结果是未定义的

4.19
    (a)先判断ptr是否为空指针，然后解引用ptr，并将ptr后移一位
    (b)先判断ival是否为0，然后判断ival+1是否为0
    (c)不正确，因为除了&&、||、?:、,四个运算符外，其他运算符都没有定义元素的执行顺序
        可以修改为vec[ival] <= vec[ival + 1]
    
4.20
    (a)合法，解引用当前iter，然后将iter后移一位
    (b)不合法，因为iter解引用后为string类型，不支持递增
    (c)不合法，解引用运算符的优先级低于点运算符
    (d)合法，调用iter指向的string对象的empty()函数
    (e)不合法，由于前置++运算符和解引用运算符的优先级相同，且都满足右结合律，因此这个表达式相当于++(*iter)，但是string 类型没有 ++ 操作。
    (f)合法，判断迭代器当前元素是否为空，然后迭代器递增。


