4.1
    105

4.2
    (a)*(vec.begin())
    (b)(*(vec.begin()) + 1

4.3
    可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。
    
4.4
    ((12/3)*4)+(5*15)+((24%4)/2)
    结果为91
    code

4.5
    (a)-86
    (b)-18
    (c)0
    (d)-2

4.6
    x & 1 == 0 ? 偶数 : 奇数

4.7
    溢出是数据超出了当前数据类型所能表达的最小或最大数字
    int a = INT_MAX + 1;
    int a = INT_MIN - 1;
    unsigned a = -1;

4.8
    逻辑与中先求解左侧运算对象，如果求解结果为true则求解右侧运算对象，如果求解结果为false，则不再求解右侧运算对象
    逻辑与中先求解左侧运算对象，如果求解结果为false则求解右侧运算对象，如果求解结果为true，则不再求解右侧运算对象
    相等性运算符中运算对象的求值顺序不确定

4.9
    先判断cp，由于cp不为NULL，接着判断*cp，由于*cp的值为'H'不为0，所以执行if中语句

4.10
    int a;
    while((cin >> a) && a != 42) ;

4.11
    if(a > b && b > c && c > d)

4.12
    这个表达式等价于i != (j < k)，首先得到 j < k 的结果为 true 或 false，转换为整数值是 1 和 0，然后判断 i 不等于 1 和 0 ，最终的结果为 bool 值。

4.13
    (a)i=3, d=3.0
    (b)d=3.5, i = 3

4.14
    第一个语句出错，赋值运算符左侧必须是一个可修改的左值，二字面值是右值
    第二个语句永远为true

4.15
    int *p = 0是合法的
    0可以赋值给任何对象，这里0隐式地转换为null_ptr，此题错在指针类型不能隐式地转换为int整形类型。
    可修改为dval = ival = *pi = 1;

4.16
    (a)因为=运算符的优先级低于!=运算符，应该改为if((p = getPtr()) != 0)
    (b)应该使用==运算符，而不应该是用=运算符

4.17
    前置递增运算符先将运算对象+1，然后以左值形式返回运算对象
    后置递增运算符以右值返回运算对象的副本，然后将运算对象+1

4.18
    将会跳过vector中的第一个元素，并且最后会对v.end()进行取值，结果是未定义的

4.19
    (a)先判断ptr是否为空指针，然后解引用ptr，并将ptr后移一位
    (b)先判断ival是否为0，然后判断ival+1是否为0
    (c)不正确，因为除了&&、||、?:、,四个运算符外，其他运算符都没有定义元素的执行顺序
        可以修改为vec[ival] <= vec[ival + 1]
    
4.20
    (a)合法，解引用当前iter，然后将iter后移一位
    (b)不合法，因为iter解引用后为string类型，不支持递增
    (c)不合法，解引用运算符的优先级低于点运算符
    (d)合法，调用iter指向的string对象的empty()函数
    (e)不合法，由于前置++运算符和解引用运算符的优先级相同，且都满足右结合律，因此这个表达式相当于++(*iter)，但是string 类型没有 ++ 操作。
    (f)合法，判断迭代器当前元素是否为空，然后迭代器递增。

4.21
    code

4.22
    code
    if语句版本的容易理解，因为多个条件运算符嵌套会导致代码可读性降低

4.23
    因为+的优先级比==高，所以最后会是一个字符串和一个字符进行比较，出错；
    应该改为s + (s[s.size() - 1] == 's' ? "" : "s");

4.24
    根据左结合律的含义，该式等价于：
    finalgrade = ((grade > 90) ? "high pass" : (grade < 60))?"fail":"pass";
    先考查grade > 90是否成立，如果成立，第一个条件表达式的值为＂highpass＂；如果不成立，第一个条件表达式的值为grade < 60。这条语句是无法编译通过的，因为条件运算符要求两个结果表达式的类型相同或者可以互相转化。即使假设语法上通过，也就是说，第一个条件表达式的求值结果分为3种，分别是＂high pass＂、1和0。接下来根据第一个条件表达式的值求解第二个条件表达式，求值结果是＂fail＂或＂pass＂。上述求值过程显然与我们的期望是不符的。

4.25
    1111 1111 1111 1111 1110 0011 1000 0000

4.26
    unsigned int类型在计算机中占多少位？

4.27
    (a)3
    (b)7
    (c)true
    (d)true

4.28
    code

4.29
    应该输出：
    10
    未定义
    code验证：
    10
    2
    因为在我的机器上一个int *占8个字节

4.30
    (a)(sizeof x) + y
    (b)sizeof(p->mem[i])
    (c)(sizeof a) < b
    (d)sizeof(f())

4.31
    因为程序中只是需要将ix和cnt进行加1和减1，不需要原本的值，所以使用前置版本的递增递减运算符
    不需要改动

4.32
    就是用指针ptr和下标ix遍历ia数组

4.33
    (someValue ? ++x, ++y : --x), --y
    如果 someValue的值为真，x 和 y 的值都自增并返回 y 值，然后丢弃 y 值，y递减并返回 y 值。如果 someValue的值为假，x 递减并返回 x 值，然后丢弃 x 值，y递减并返回 y 值。
    
4.34
    (a)fval转换为布尔类型
    (b)ival选转换为float类型，然后和fval相加后，结果转换为double类型
    (c)cval先转换为int类型，和ival相乘的结果转换为double类型

4.35
    (a)'a'转换为int类型，然后+3后结果转换为char类型
    (b)ival先转为double类型，然后ui也转为double类型，最后结果转为float类型
    (c)ui转换为float类型，和fval相乘后，结果转换为double类型
    (d)ival先转为floagr，和fval相加后转为double类型，最后结果转为char类型

4.36
    i *= static_cast<int>(d);

4.37
    (a)pv = static_cast<void *>(const_cast<string *>(ps))
    (b)i = static_cast<int>(*pc)
    (c)pv = static_cast<void*>(&d)
    (d)pc = static_cast<char *>(pv)

3.48
    将j/i的结果强制转换为double类型并赋值给slope变量



