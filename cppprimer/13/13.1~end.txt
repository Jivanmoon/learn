13.1
    拷贝构造函数是第一个参数是自身类类型的引用，且任何额外参数都有默认值的构造函数
    拷贝构造函数用于：
    1、使用=定义变量时
    2、将一个对象作为实参传递给一个非引用类型的形参
    3、从一个返回类型为非引用类型的函数返回一个对象
    4、用花括号列表初始化一个数组中的元素或一个聚合类中的成员
    5、标准库容器初始化或调用其insert或push成员

13.2
    拷贝构造函数的第一个参数必须是自身类类型的引用

13.3
    StrBlob中元素复制，且智能指针计数加一。StrBlobStr中元素复制，弱指针复制不影响计数器
    拷贝StrBlob时，其shared_ptr成员的引用计数会增加。拷贝StrBlobPtr，unique_ptr成员的引用计数不变，其引用了shared_ptr，但不影响shared_ptr的引用计数
13.4
    Point global;
    Point foo_bar(Point arg) // 1
    {
        Point local = arg, *heap = new Point(global); // 2: Point local = arg,  3: Point *heap = new Point(global) 
        *heap = local; 
        Point pa[4] = { local, *heap }; // 4, 5
        return *heap;  // 6
    }
    这6个部分使用了拷贝构造函数

13.5
    code

13.6
    拷贝赋值运算符是一个名为 operator= 的函数。
    当赋值运算发生时就会用到它。
    合成拷贝赋值运算符可以用来禁止该类型对象的赋值，但其主要工作是完成赋值
    如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。

13.7
    StrBlob：会通过shared_ptr类的拷贝赋值运算符将shared_ptr拷贝赋值，且其计数器自增。
    StrBlobPtr：会通过weak_ptr类的拷贝赋值运算符将weak_ptr拷贝赋值。curr调用内置类型的赋值运算符。

13.8
    code

13.9
    析构函数：释放对象使用的资源，并销毁对象的非static数据成员
            析构函数是类的一个成员函数，名字波浪号接类名，没有返回值，也不接受参数，不能被重载，对一个给定类唯一
    析构函数完成什么工作：
        1、在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁
        2、不像构造函数有初始化列表，析构函数的析构部分是隐式的，成员销毁时发生什么完全依赖成员的类型
        3、销毁类类型的成员执行类类型的析构函数
        4、内置类型没有析构函数，销毁内置类型成员什么也不需要做
        5、隐式销毁一个内置指针类型的成员不会delete它所指向的对象
        6、与普通指针不同，智能指针是类类型，所以具有析构函数。智能指针成员在析构阶段会被自动销毁
    合成析构函数：
        1、当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数
        2、对于某些类，合成析构函数被用来阻止该类型的对象被销毁
        3、一般，合成析构函数的函数体为空
        4、认识到析构函数体自身并不直接销毁成员很重要。成员是在析构函数体之后隐含的析构阶段被销毁的，在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的

13.10
    当一个 StrBlob 对象被销毁时，shared_ptr 的引用计数会减少。当 StrBlobPtr 对象被销毁时，不影响引用计数。

13.11
    code

13.12
    bool fcn(const Sales_data *trans, Sales_data accum)
    {
        Sales_data item1(*trans), item2(accum);
        return item1.isbn() != item2.isbn();
    }
    函数结束时，accum,item1,item2都会调用析构函数，因此会发生三次

13.13
    code

13.14
    a,b,c的mysn成员是一样的

13.15
    会改变，会输出3个不同的数。并且这3个数并不是a、b、c当中的数。因为调用函数f的过程中也调用了拷贝构造函数

13.6
    会输出 a、b、c的数。

13.17
    code

13.18
    code

13.19
    不需要自定义任何拷贝控制成员，使用编译器合成版本即可

13.20
    TextQuery和QueryResult的数据成员要么是容器map和string，要么是shared_ptr，都是值语义
    在拷贝、赋值时，会产生独立的副本；在销毁时，依次逆序销毁成员

13.21
    不需要，因为都是值语义，使用合成版本即可    

13.22
    code

13.23
    我的代码原本的版本拷贝赋值运算符实现中并没有释放运算符左侧的对象的内存空间，造成了内存泄露

13.24
    如果未定义析构函数，则编译器会添加一个默认析构函数，当对象需要销毁时，对象中string指针指向空间不会被释放，造成内存泄露
    如果未定义拷贝构造函数，编译器会添加一个默认拷贝构造函数，则对string指针成员的拷贝操作会简单的拷贝指针的值，导致多个HasPtr对象可能指向相同的内存

13.25
    拷贝构造函数和拷贝赋值运算符要重新动态分配内存。因为 StrBlob 使用的是智能指针，当引用计数为0时会自动释放对象，因此不需要析构函数。

13.26
    code

13.27
    code

13.28
    code

13.29
    因为函数的调用实参类型不同，因此调用的并不是同一个swap函数

13.30
    code

13.31
    code
    我设置的vector中包含3个元素，但是排序时并没有调用swap函数，查找资料后发现在tdm-gcc4.8.1的STL实现中，当元素
    数小于等于16时，sort使用的是插入排序算法，且未使用swap交换元素，而是内存区域的整片移动。
    因此会发现swap并未被调用（没有相应输出）。而当元素数量大于等于17时，就会发现sort调用了swap。
    因为此时sort采用的是快速排序算法，使用了swap交换元素。但会发现，交换元素的次数可能比你预期的
    快速排序算法的交换元素次数少得多。原因是，在快速排序算法递归排序的过程中，如果子序列长度小于等于16，
    又会转到插入排序算法，而不会继续递归直至子序列长度变为1。

13.32
    不会。类值的版本利用swap交换指针不用进行内存分配，因此得到了性能上的提升。类指针的版本本来就不用进行内存分配，所以不会得到性能提升。

13.33
    因为 save 和 remove 操作需要更新指定 Folder。

13.34
    code

13.35
    则在拷贝或者赋值之后，Folder和Message的关系就会错乱

13.36
    code

13.37
    code in 13.36

13.38
    因为swap的开销很大，需要扫描两次需要交换的Message的Folder，而正常实现的赋值操作符只需要扫描一次
    使用copy and swap来实现，则copy+swap的开销大于直接实现

13.39
    code

13.40
    code

13.41
    因为first_free指向的是第一个未构造的内存空间，因此使用前置递增运算符，这样才是在第一个未构造的空间上构造元素
    如果使用后置递增运算，则会有内存空间不会被构造

13.42
    code

13.43
    for_each和lambda一起使用更简洁，但是for循环更符合阅读习惯
    code

13.44
    code

13.45
    左值引用，也就是常规引用，返回左值的函数有赋值、下标、解引用和前置递增/递减运算符，左值有持久的状态。
    右值引用就是必须绑定到右值上的引用，返回右值的函数包括算术、关系、位及后置递增/递减运算符，右值要么是字面常量，要么就是在表达式求值过程中创建的临时对象。

13.46
    int f();
    vector<int> vi(100);
    int? r1 = f(); // f()的返回值相当于一个常量，只能做右值引用或const引用，所以是int &&r = f(); 或者const int &r1 = f();
    int? r2 = vi[0];// 下标运算返回左值，所以是int &r = vi[0] 
    int? r3 = r1;  // r1此时是等价于变量，所以是int &r3 = r1;
    int? r4 = vi[0] * f(); // 算术运算产生右值，所以是int &&r4 = vi[0] * f();

13.47~13.38
    code in 13.47

13.49
    code

13.50
    code

13.51
    不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr，编译器知道要返回的对象将要被销毁，因此会执行一种特殊的"拷贝" – 移动。最常见的就是从函数返回unique_ptr。

13.52
    hp = hp2;//hp2是一个左值，hp2通过拷贝构造函数来拷贝，拷贝构造函数将分配一个新的string，并拷贝hp2指向的string。
    hp = std::move(hp2);//移动构造函数移动hp2，调用std::move将一个右值引用绑定到hp2上。在此情况下，拷贝构造函数和移动构造函数都是可行的。由于实参是一个右值引用，所以移动构造函数是精确匹配的。因此移动构造函数从hp2拷贝指针，而不会分配内存。

13.53
    HasPtr的赋值运算符使用了拷贝并交换来实现，因此会出现实参拷贝给形参的现象，效率较低。
    code

13.54
    报错：13.53.cpp:57:24: error: ambiguous overload for ‘operator=’ (operand types are ‘HasPtr’ and ‘std::remove_reference<HasPtr&>::type {aka HasPtr}’)
     hp1 = std::move(*pH);

13.55
    code

13.56
    会无限循环，并最终栈溢出

13.57
    Foo(*this)返回的是一个右值，能够调用sorted的右值版本，返回排序后的Foo。

13.58
    code



