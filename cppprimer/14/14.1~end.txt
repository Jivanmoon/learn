14.1
    区别：
    1、重载运算符必须是一个类的成员或者至少有一个参数是类类型。
    2、可以直接通过对象调用一个重载运算符，如data1.operator+(data2)。
    3、使用重载的运算符本质上是函数调用，所以这些运算符指定了运算对象的求值顺序或短路求值属性，这些规则无法应用到重载运算符上，比如逻辑运算符、关系运算符和逗号运算符，不建议使用。
    相同：
    重载运算符的优先级和结合律与对应的内置运算符保持一致。

14.2
    code

14.3
    (a)内置的==
    (b)string重载的==
    (c)vector重载的==
    (d)string重载的==

14.4
    (a) % 一般定义为非成员。
    (b) %= 一般定义为类成员，能够改变对象的状态。
    (c) ++ 一般定义为类成员，能够改变对象的状态。
    (d) -> 必须定义为类成员
    (e) << 一般定义为非成员
    (f)&& 一般定义为非成员。
    (g) == 一般定义为非成员。
    (h) () 必须定义为类成员

14.5
    code

14.6
    code in 14.2

14.7
    code

14.8
    code

14.9
    code in 14.2

14.10
    (a) 格式正确。
    (b) 不合法的输入。因为程序试图将 0-210-99999-9 转换为 float。
        但是会输出"10 24 22.8 0.95"

14.11
    有错误，没有设置输入错误检查
    会将错误的信息输入到对象中，输入的对象输出结果为"10 24 22.8 0.95"

14.12
    code

14.13
    可以定义一个减法运算符

14.14
    为了节省代码？？？

14.15
    不需要添加算术运算符，应该逻辑上不需要

14.16
    code

14.17
    略

14.18
    code

14.19
    code

14.20
    code in 14.2

14.21
    code
    性能上没有任何优势，并且代码可读性不好

14.22
    code

14.23
    code

14.24~14.25
    略

14.26
    code

14.27~14.28
    code in 14.27

14.29
    因为递增递减运算符会改变当前对象的状态

14.30
    code

14.31
    因为StrBlobPtr类不需要管理内存，因此使用合成的版本就可以

14.32
    code

14.33
    重载运算符函数的参数数量和该运算符作用的运算对象的数量一样多。函数调用运算符()最多可以传256个参数，因此在重载时，最多也能接受256个参数用作运算。

14.34
    code

14.35
    code

14.36
    code

14.37
    code

14.38
    code

14.39
    code

14.40
    code







