2.14
    合法，它将输出：100 45 

2.15
    (b)不合法，因为引用类型的初始值必须是一个对象
    (d)不合法，因为引用类型必须初始化

2.16
    (a)合法，因为r2为变量d的引用，因此执行的操作为将变量d赋值为3.14159
    (b)合法，执行的操作为将d赋值为变量i的值
    (c)合法，将变量i赋值为变量d的值
    (d)合法，将变量i赋值为变量d的值

2.17
    输出结果为：10 10

2.18
    见程序

2.19
    指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内可以先后指向几个不同的对象
    指针无需再定义时赋初值

2.20
    将i的值赋值为i*i

2.21
    (a)非法，因为指针类型必须与它所指的对象类型严格匹配
    (b)非法，不能用int类型对int *类型赋值

2.22
    if(p)利用当前的指针值进行判断
    if(*p)利用当前指针指向的值进行判断

2.23
    应该不能判断指针p是否指向了一个合法的对象，因为如果指针p没有被初始化，p存放的是一个随机的地址，这是一件极其危险的事情，再者，如果p没有被合法的初始化，恶意存放了一个地址，也是危险的。所以，需要程序员自己清楚指针是否被合法使用。

2.24
    因为void *类型的指针可以可用于存放任意对象的地址，而long *类型的指针只能存放long类型对象的地址

2.25
    (a)ip为int *指针，i为int类型变量，r为i的引用
    (b)i为int类型变量，ip为int *的空指针
    (c)ip为int *指针，ip2为int类型变量

2.26
    (a)不合法，因为const对象必须被初始化
    (d)不合法，因为const对象不能被修改

2.27
    (a)不合法，不能用字面值对引用赋值
    (b)合法
    (c)合法，可以用字面值赋值常量引用
    (d)合法
    (e)合法
    (f)不合法，引用没有顶层const
    (g)合法

2.28
    (a)定义int型变量i，定义常量指针cp，不合法，因为cp没有初始化
    (b)定义指向int的指针变量p1，定义常量指针p2，不合法，因为p2没有初始化
    (c)定义常量int对象ic，和常量引用r并初始化为ic，不合法，因为ic没有初始化
    (d)定义具有顶层const和底层const的指针p3，不合法，因为p3没有初始化
    (e)定义指向常量的指针

2.29
    (a)合法，可以用常量对象为非常量对象赋值
    (b)非法，不能将指向常量的指针赋值给普通指针
    (c)非法，不能将普通指针指向常量对象
    (d)非法，不能给常量指针赋值
    (e)非法，常量指针不能修改值
    (f)非法，不能修改常量
    
2.30
    v2是底层const
    p2是顶层const
    p3是底层const+顶层const
    r2是底层const

2.31
    知识点：顶层const的拷贝不受限制，但是底层const的拷贝的对象必须具有相同的底层const资格。一般来说：非常量可以赋值给常量，反之则不行
    (1)r1 = v2合法，v2是常量，可以给其他对象赋值
    (2)p1 = p2非法，因为p2包含底层const，而p1没有
    (3)p2 = p1合法，int *能够转换为cons int *
    (4)p1 = p3非法，因为p3既是顶层const也是底层const，而p1没有底层const
    (5)p2 = p3合法，因为p2和p3都具有底层const

2.32
    非法，原因是不能使用一个int类型变量初始化int类型指针，可修改为int null = 0, *p = 0;

2.33
    a赋值为42整数
    b赋值为42整数
    c赋值为42整数
    d出错，因为d的类型为int *,不能使用字面值int类型进行赋值
    e出错，因为d的类型为const int *,不能使用字面值int类型进行赋值
    g为绑定到ci的整形常量引用，该语句出错

2.34
    见代码

2.35
    j的类型为int
    k的类型为const int &
    p的类型const int *
    j2的类型为const int
    k2的类型为const int &
    验证见代码2.35.cpp，验证方法为：鼠标移到变量上就出来了......

2.36
    
