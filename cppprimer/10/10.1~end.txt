10.1
    code

10.2
    code

10.3
    accumulate(v.cbegin(), v.cend(), 0);

10.4
    由于vector中的元素类型为double，而accumulate的第三个参数是int类型自面值，因此执行求和操作会将vector中的double元素先转换为int再求和

10.5
    由于C风格字符串的==运算符是默认比较两个C风格字符串起始地址的值是否相等，因此该程序与调用者期望不符

10.6
    code

10.7
    (a)vec的实际大小为0，因此使用copy会导致错误
    可以修改为：copy(lst.cbegin(), lst.cend(), back_inserter(vec));
    (b)reserve函数的作用是调整容器空间，但是fill_n要求的并不是足够的空间，而是足够的元素，此时vec仍然是空的，而fill_n算法并不具备向容器添加元素的能力，因此fill_n仍然失败
    可以修改为使用back_inserter来向容器中添加元素

10.8
    因为改变容器大小的是插入迭代器，而不是标准库算法

10.9
    code

10.10
    算法的接口是迭代器，而迭代器用来改变容器。这样的设计使得算法具有通用性。

10.11
    code

10.12
    code

10.13
    code

10.14
    code

10.15
    code

10.16
    code

10.17
    code

10.18
    code

10.19
    code

10.20
    code

10.21
    code

10.22
    code

10.23
    假设被绑定的函数接受 n 个参数，那么bind 接受 n + 1 个参数。

10.24
    code

10.25
    code



