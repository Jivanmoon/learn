7.1
    code

7.2~7.4
    code

7.5
    code
    应该是const的，因为这些操作并不修改数据成员的值，并且将函数定义为const可以使常量对象也可以调用

7.6~7.7
    code

7.8
    因为read需要修改Sales_data变量，而print不需要

7.9
    code

7.10
    read 函数的返回值是 istream 对象，if语句中条件部分的作用是从输入流中读取数据给两个data对象。

7.11~7.13
    code

7.14
    Sales_data() : units_sold(0) , revenue(0) { }

7.15
    code

7.16
    没有限定；接口成员应该定义在public说明符之后，内部成员应该定义在private说明符之后

7.17
    有区别，使用class和struct的唯一区别就是class的默认访问权限是private，而struct是public

7.18
    将类内部分成员设置为外部不可见，而提供部分接口给外面，这样的行为叫做封装。封装隐藏了具体的实现，当我们使用某个抽象数据类型时，只需要考虑它提供什么接口操作，而不用去考虑它的具体实现。

7.19
    应该将name和address成员生命为private，把构造函数、read、print、getName、getAddr生命为public

7.20
    友元应该用于将是类接口一部分但不是类成员的函数声明为友元
    优点：为接口编程提供方便
    缺点：一定程度上破坏了封装性

7.21~7.22
    code

7.23~7.24
    code

7.25
    可以，因为Screen中使用的string、算数类型以及vector都可以依赖默认版本的拷贝和赋值

7.26
    code in 7.21

7.27
    code

7.28
    如果返回类型是Screen，那么move返回的是 *this 的一个副本，因此set函数只能改变临时副本而不能改变myScreen的值。

7.29
    经验证后，推测正确

7.30
    优点：程序的意图更明确，函数的参数可以与成员同名此时需要使用显式使用this指针
    缺点：繁琐

7.31
    code

7.32
    code

7.33
    会出错，可以修改为
    Screen::pos
    Screen::size() const {
        return height * width;
    }

7.34
    则类中typedef之前的所有出现pos的声明语句都会出错

7.35
    typedef string Type;
    Type initVal(); // use `string`
    class Exercise {
    public:
        typedef double Type;
        Type setVal(Type); // use `double`
        Type initVal(); // use `double`
    private:
        int val;
    };

    Type Exercise::setVal(Type parm) {  // first is `string`, second is `double`
        val = parm + initVal();     // Exercise::initVal()
        return val;
    }
    修改为
    Exercise::Type Exercise::setVal(Type parm) {
        val = parm + initVal();
        return val;
    }



