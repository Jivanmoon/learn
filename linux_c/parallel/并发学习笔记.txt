            并发（信号、线程）

异步事件处理：查询法、通知法
    如果异步事件频率高，则适合查询法
    如果异步事件频率低，则适合通知法
一、信号
1、信号的概念
    信号是软件层面的中断。
    信号的响应依赖于中断。
    
2、signal()
    void (*signal(int signum, void (*func)(int)))(int);
    信号会打断阻塞的系统调用！！！！！！！！！！

3、信号的不可靠
    
4、可重入函数
    第一次调用没有结束，就进行了第二次调用，但是程序不会出错。这就是可重入函数
    所有的系统调用都是可重入的，一部分库函数也是可重入的，比如说：memcpy，后缀为_r版本的库函数
    
5、信号的响应过程
    信号从收到到响应有一个不可避免的延迟，因为程序只有在中断之后从内核态切换到用户态时才回去检查当前是否有中断，此时才能响应中断
    思考：如何忽略掉一个信号？（其实就是把对应信号的屏蔽字置为0）
            标准信号为什么要丢失？（因为进程是使用位图来记录待处理的信号，而位图对一种信号只能记录一个）
    标准信号的响应没有严格的顺序

6、信号常用函数
    kill()：给一个进程发信号
    raise()：给当前进程发信号
    alarm()：计时函数，倒计时为0时给当前进程发送信号，当程序中出现多个alarm时，只有最后一个alarm生效
    setitimer()：比alarm功能更强大的计时函数
    sig_atomic_t类型：当把变量声明为该类型会保证该变量在使用或赋值时， 无论是在32位还是64位的机器上都能保证操作是原子的， 它会根据机器的类型自动适应。
    例：使用单一计时器，利用alarm或setitimer构造一个函数，实现任意数量的计时器

    pause()：暂停程序，等待一个信号到来
    abort()
    system()
    sleep()：有些平台下sleep使用alarm+pause实现的，但是alarm在程序中出现多个会出问题，所以不建议使用sleep函数
    nanosleep()、usleep()、select()：可以替换sleep函数

7、信号集
    信号集类型：sigset_t
    sigemptyset()
    sigfillset()
    sigaddset()
    sigdelset()
    sigismember()

8、信号屏蔽字/pending集的处理
    sigprocmask()

9、扩展
    sigsuspend()
    sigaction()
    setitimer()
10、实时信号
二、线程